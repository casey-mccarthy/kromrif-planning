{% comment %}
Live Updates Component using HTMX Server-Sent Events

Usage:
{% include 'components/live_updates.html' with update_url='/api/live-updates/' update_target='#live-content' %}

Parameters:
- update_url: SSE endpoint URL (required)
- update_target: Target element to update (required)
- update_events: Comma-separated list of events to listen for (optional)
- auto_connect: Boolean, auto-connect on load (default: true)
- show_status: Boolean, show connection status (default: true)
- reconnect_delay: Reconnection delay in ms (default: 3000)
{% endcomment %}

{% with auto_connect|default:true as connect %}
{% with show_status|default:true as status %}
{% with reconnect_delay|default:3000 as delay %}

<div x-data="liveUpdates()" x-init="init()" class="live-updates">
    {% if status %}
        <!-- Connection Status -->
        <div x-show="showStatus" 
             x-transition
             class="fixed top-4 right-4 z-40">
            <div x-bind:class="connectionClass" 
                 class="flex items-center px-3 py-2 rounded-md shadow-sm text-sm font-medium">
                <div x-bind:class="indicatorClass" 
                     class="w-2 h-2 rounded-full mr-2"></div>
                <span x-text="connectionStatus"></span>
                
                <button x-show="!connected" 
                        x-on:click="connect()"
                        class="ml-2 text-xs underline hover:no-underline">
                    Retry
                </button>
            </div>
        </div>
    {% endif %}
    
    <!-- Auto-refresh fallback -->
    <div x-show="!connected && enableFallback" 
         x-transition
         class="bg-yellow-50 border border-yellow-200 rounded-md p-4 mb-4">
        <div class="flex">
            <div class="flex-shrink-0">
                <svg class="h-5 w-5 text-yellow-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd" />
                </svg>
            </div>
            <div class="ml-3">
                <h3 class="text-sm font-medium text-yellow-800">
                    Live updates unavailable
                </h3>
                <div class="mt-2 text-sm text-yellow-700">
                    <p>Using automatic refresh instead. Page will update every <span x-text="fallbackInterval / 1000"></span> seconds.</p>
                </div>
                <div class="mt-3">
                    <div class="flex">
                        <button x-on:click="connect()" 
                                class="bg-yellow-50 text-yellow-800 font-medium rounded-md text-sm px-3 py-2 hover:bg-yellow-100 border border-yellow-300">
                            Try live updates again
                        </button>
                        <button x-on:click="disableFallback()" 
                                class="ml-3 bg-transparent text-yellow-800 font-medium rounded-md text-sm px-3 py-2 hover:bg-yellow-100">
                            Disable auto-refresh
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
function liveUpdates() {
    return {
        eventSource: null,
        connected: false,
        connecting: false,
        showStatus: true,
        enableFallback: false,
        fallbackInterval: 30000, // 30 seconds
        fallbackTimer: null,
        reconnectAttempts: 0,
        maxReconnectAttempts: 5,
        
        get connectionStatus() {
            if (this.connected) return 'Live updates active';
            if (this.connecting) return 'Connecting...';
            return 'Disconnected';
        },
        
        get connectionClass() {
            if (this.connected) return 'bg-green-100 text-green-800';
            if (this.connecting) return 'bg-yellow-100 text-yellow-800';
            return 'bg-red-100 text-red-800';
        },
        
        get indicatorClass() {
            if (this.connected) return 'bg-green-400 animate-pulse';
            if (this.connecting) return 'bg-yellow-400 animate-pulse';
            return 'bg-red-400';
        },
        
        init() {
            {% if connect %}
                this.connect();
            {% endif %}
            
            // Hide status after a few seconds when connected
            this.$watch('connected', (connected) => {
                if (connected) {
                    setTimeout(() => {
                        this.showStatus = false;
                    }, 3000);
                } else {
                    this.showStatus = true;
                }
            });
            
            // Handle page visibility changes
            document.addEventListener('visibilitychange', () => {
                if (document.visibilityState === 'visible' && !this.connected) {
                    this.connect();
                }
            });
            
            // Handle online/offline events
            window.addEventListener('online', () => {
                if (!this.connected) {
                    this.connect();
                }
            });
            
            window.addEventListener('offline', () => {
                this.disconnect();
            });
        },
        
        connect() {
            if (this.connecting || this.connected) return;
            
            this.connecting = true;
            this.showStatus = true;
            
            try {
                this.eventSource = new EventSource('{{ update_url }}');
                
                this.eventSource.onopen = () => {
                    this.connected = true;
                    this.connecting = false;
                    this.reconnectAttempts = 0;
                    this.enableFallback = false;
                    this.clearFallback();
                    
                    console.log('Live updates connected');
                };
                
                this.eventSource.onmessage = (event) => {
                    this.handleUpdate(JSON.parse(event.data));
                };
                
                // Listen for specific events if provided
                {% if update_events %}
                    const events = '{{ update_events }}'.split(',');
                    events.forEach(eventType => {
                        this.eventSource.addEventListener(eventType.trim(), (event) => {
                            this.handleUpdate(JSON.parse(event.data), eventType.trim());
                        });
                    });
                {% endif %}
                
                this.eventSource.onerror = () => {
                    this.connected = false;
                    this.connecting = false;
                    
                    if (this.eventSource.readyState === EventSource.CLOSED) {
                        this.handleDisconnection();
                    }
                };
                
            } catch (error) {
                console.error('Failed to connect to live updates:', error);
                this.connected = false;
                this.connecting = false;
                this.handleDisconnection();
            }
        },
        
        disconnect() {
            if (this.eventSource) {
                this.eventSource.close();
                this.eventSource = null;
            }
            
            this.connected = false;
            this.connecting = false;
            this.clearFallback();
        },
        
        handleUpdate(data, eventType = null) {
            console.log('Live update received:', data, eventType);
            
            // Handle different update types
            switch (data.type) {
                case 'refresh':
                    this.refreshTarget(data.target || '{{ update_target }}');
                    break;
                    
                case 'update':
                    this.updateContent(data.target || '{{ update_target }}', data.content);
                    break;
                    
                case 'append':
                    this.appendContent(data.target || '{{ update_target }}', data.content);
                    break;
                    
                case 'notification':
                    KromrifUtils.showNotification(data.message, data.level || 'info');
                    break;
                    
                case 'redirect':
                    window.location.href = data.url;
                    break;
                    
                case 'reload':
                    window.location.reload();
                    break;
                    
                default:
                    // Generic content update
                    if (data.content) {
                        this.updateContent(data.target || '{{ update_target }}', data.content);
                    }
            }
            
            // Show brief notification for updates
            if (data.message && data.type !== 'notification') {
                KromrifUtils.showNotification(data.message, 'info', 2000);
            }
        },
        
        refreshTarget(target) {
            const element = document.querySelector(target);
            if (element && element.hasAttribute('hx-get')) {
                htmx.trigger(element, 'refresh');
            } else if (element) {
                // Fallback: reload page section
                htmx.ajax('GET', window.location.pathname, {
                    target: target,
                    swap: 'innerHTML'
                });
            }
        },
        
        updateContent(target, content) {
            const element = document.querySelector(target);
            if (element) {
                element.innerHTML = content;
                
                // Re-initialize Alpine.js if available
                if (window.Alpine) {
                    Alpine.initTree(element);
                }
                
                // Process any HTMX attributes
                htmx.process(element);
            }
        },
        
        appendContent(target, content) {
            const element = document.querySelector(target);
            if (element) {
                const wrapper = document.createElement('div');
                wrapper.innerHTML = content;
                
                while (wrapper.firstChild) {
                    element.appendChild(wrapper.firstChild);
                }
                
                // Re-initialize Alpine.js if available
                if (window.Alpine) {
                    Alpine.initTree(element);
                }
            }
        },
        
        handleDisconnection() {
            console.log('Live updates disconnected');
            
            this.reconnectAttempts++;
            
            if (this.reconnectAttempts <= this.maxReconnectAttempts) {
                // Attempt to reconnect with exponential backoff
                const delay = {{ delay }} * Math.pow(2, this.reconnectAttempts - 1);
                
                setTimeout(() => {
                    if (!this.connected) {
                        this.connect();
                    }
                }, delay);
            } else {
                // Enable fallback after max attempts
                this.enableFallback = true;
                this.startFallback();
            }
        },
        
        startFallback() {
            if (this.fallbackTimer) return;
            
            this.fallbackTimer = setInterval(() => {
                if (!this.connected && document.visibilityState === 'visible') {
                    this.refreshTarget('{{ update_target }}');
                }
            }, this.fallbackInterval);
        },
        
        clearFallback() {
            if (this.fallbackTimer) {
                clearInterval(this.fallbackTimer);
                this.fallbackTimer = null;
            }
        },
        
        disableFallback() {
            this.enableFallback = false;
            this.clearFallback();
        }
    }
}

// Global function to send live updates (for testing)
window.sendLiveUpdate = function(data) {
    const event = new CustomEvent('liveUpdate', { detail: data });
    document.dispatchEvent(event);
};
</script>

{% endwith %} {# delay #}
{% endwith %} {# status #}
{% endwith %} {# connect #}